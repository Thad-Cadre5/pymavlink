#!/usr/bin/env python
'''
MAVLink compatible TypeScript interfaces

Thad Thompson
'''

import os
import re
import textwrap
from . import mavparse, mavtemplate

t = mavtemplate.MAVTemplate()


def generate_preamble(outf, msgs, basename, args, xml):
    print("Generating preamble")
    print("Protocol marker", xml.protocol_marker)
    t.write(outf, """
/**
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: ${FILELIST}

Note: this file has been auto-generated. DO NOT EDIT
*/

import JSBI from "jsbi";

const WIRE_PROTOCOL_VERSION = '${WIRE_PROTOCOL_VERSION}';
const DIALECT = '${DIALECT}';

export interface IMavlinkHeader 
{
    message_id: number;
    system_id: number;
    component_id: number;
    sequence: number;
    payload_length: number;
    is_mavlink_v2: boolean;
    incompat_flags?: number;
    compat_flags?: number;
    signature_link_id?: number;
    signature_timestamp?: JSBI;
    signature?: ArrayBuffer;
}

""", {'FILELIST': ",".join(args),
      'PROTOCOL_MARKER': xml.protocol_marker,
      'DIALECT': os.path.splitext(os.path.basename(basename))[0],
      'crc_extra': xml.crc_extra,
      'WIRE_PROTOCOL_VERSION': xml.wire_protocol_version})


def bin_format_string(msg):
    """ """
    map = {
        'float':    'f',
        'double':   'd',
        'char':     'c',
        'int8_t':   'b',
        'uint8_t':  'B',
        'int16_t':  'h',
        'uint16_t': 'H',
        'int32_t':  'i',
        'uint32_t': 'I',
        'int64_t':  'q',
        'uint64_t': 'Q',
    }

    formats = []
    for field in msg.ordered_fields:
        fmt = map[field.type]
        if field.array_length:
            fmt = str(field.array_length) + fmt
        formats.append(fmt)
    return ''.join(formats)


def ts_type_format(field):
    map = {
        'float':    'number',
        'double':   'number',
        'char':     'string',
        'int8_t':   'number',
        'uint8_t':  'number',
        'int16_t':  'number',
        'uint16_t': 'number',
        'int32_t':  'number',
        'uint32_t': 'number',
        'int64_t':  'JSBI',
        'uint64_t': 'JSBI',
    }

    if field.enum:
        return field.enum

    if field.array_length:
        if field.type == 'char':
            return 'string'
        elif field.type == 'uint8_t':
            return 'ArrayBuffer'
        return map[field.type] + "[]"
    return map[field.type]


def generate_message_ids(outf, msgs):
    print("Generating message IDs")
    outf.write("export const enum MSG_ID {\n")

    for m in msgs:
        outf.write("    %-56s = %u,\n" % (m.name.upper(), m.id))

    outf.write("}\n")

    # outf.write("\n// Message IDs\n")
    # outf.write("export const %-56s = -1;\n" % "MAVLINK_MSG_ID_BAD_DATA")
    # for m in msgs:
    #     outf.write("export const %-56s = %u;\n" % ("MAVLINK_MSG_ID_" + m.name.upper(), m.id))


def generate_enums(outf, enums):
    print("Generating enums")
    # add some extra field attributes for convenience with arrays
    top_comment_wrapper = textwrap.TextWrapper(initial_indent="// ", subsequent_indent="// ", width=120, expand_tabs=False)
    element_comment_wrapper = textwrap.TextWrapper(initial_indent="// ", subsequent_indent="%60s// " % "", width=120)
    for e in enums:
        if len(e.description) > 0:
            outf.write("%s\n" % top_comment_wrapper.fill(e.description))

        outf.write("export const enum %s {\n" % e.name)
        for entry in e.entry:
            if entry.name.endswith('ENUM_END'):
                continue
            outf.write("    %-44s = %6u,  %s\n" % (entry.name, entry.value, element_comment_wrapper.fill(entry.description)))
        outf.write("}\n\n")


def generate_interfaces(outf, msgs):
    print("Generating interfaces")
    top_comment_wrapper = textwrap.TextWrapper(initial_indent="// ", subsequent_indent="// ", width=120, expand_tabs=False)
    element_comment_wrapper = textwrap.TextWrapper(initial_indent="// ", subsequent_indent="%52s// " % "", width=120)
    for msg in msgs:
        if len(msg.description) > 0:
            outf.write("%s\n" % top_comment_wrapper.fill(msg.description))

        outf.write("export interface I%s {\n" % msg.name)
        outf.write("    %-30s %-16s\n" % ("header:", "IMavlinkHeader;"))
        for field in msg.fields:
            outf.write("    %-30s %-16s %s\n" % (field.name + ":", ts_type_format(field) + ";", element_comment_wrapper.fill(field.description)))

        outf.write("}\n\n")


def generate_message_descriptors(outf, msgs):
    print("Generating message descriptors")
    outf.write("\nexport const MAVLINK_MESSAGE_DESCRIPTORS = new Map([\n")
    for m in msgs:
        outf.write("  [%s, {name: \"%s\", format: \"%s\", fields: [%s], len: %d, crc_extra: %d}],\n" %
                   (m.id, m.name.upper(), bin_format_string(m), ','.join("\""+str(x)+"\"" for x in m.ordered_fieldnames), m.wire_length, m.crc_extra))
    outf.write("]);\n\n")


def write_file(outf, filename):
    """ Inject a file into the output stream """
    print("Injecting {}".format(filename))
    with open(filename, "r") as inf:
        for line in inf:
            outf.write(line)


def generate(basename, xml):
    """ Implement the mavlink generate function to output """

    SERIALIZATION_TS = os.path.join(os.path.dirname(os.path.realpath(__file__)), "typescript2", "lib", "serialization.ts")
    PARSER_TS = os.path.join(os.path.dirname(os.path.realpath(__file__)), "typescript2", "lib", "parser.ts")
    ENCODE_TS = os.path.join(os.path.dirname(os.path.realpath(__file__)), "typescript2", "lib", "encode.ts")

    if basename.endswith('.ts'):
        filename = basename
    else:
        filename = basename + '.ts'

    msgs = []
    enums = []
    filelist = []
    for x in xml:
        msgs.extend(x.message)
        enums.extend(x.enum)
        filelist.append(os.path.basename(x.filename))

    msgs.sort(key=lambda msg: msg.id)

    print("Generating %s" % filename)
    outf = open(filename, "w")
    generate_preamble(outf, msgs, basename, filelist, xml[0])
    generate_message_ids(outf, msgs)
    generate_message_descriptors(outf, msgs)
    generate_enums(outf, enums)
    generate_interfaces(outf, msgs)
    write_file(outf, SERIALIZATION_TS)
    write_file(outf, PARSER_TS)
    write_file(outf, ENCODE_TS)
    outf.close()
    print("Generated %s OK" % filename)


